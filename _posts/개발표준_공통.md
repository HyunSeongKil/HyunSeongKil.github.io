# 일반 정보

- @author SeongKil
- @since 2023-xx-xx

# 공통

## “팀으로 개발한다면 팀 코드 스타일 반드시 필요”

## 명언

- 신은 세세함에 깃들어 있다 by 루트비히 미스 반 데어 로에(건축가)
- 나중은 결코 오지 않는다 by 르블랑의 법칙
- 좋은 코드는 보기에 즐거운 코드이다 by 비야네 스트롭스트룹(C++ 창시자)
- 나쁜 코드에 주석을 달지 마라. 새로 짜라. by 브라이언 W. 커니헨, P.J. 플라우거
- 깨끗한 코드는 읽으면서 놀랄 일이 없어야 한다 by 워드 커닝햄(위키 창시자)
- 품질은 하늘에서 뚝 떨어진 위대한 방법론이 아니라 사심 없이 기울이는 무수한 관심에서 얻어진다.
- 코드 품질을 측정하는 유일한 척도 = 분당 내지르는 WTF(What The F\*ck) 횟수
- 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다. - 디미터 법칙
- 깨진 창문 이론
- 소프트웨어는 소프트해야 한다.

## 공통

사람이 읽기 좋은 코드가 좋은 코드다

- 성능등의 이슈 해결을 위한 코어 로직, 저수준 코드가 아닌 이상 코드는 사람이 읽기 편해야 함

## 보이스카우트 규칙

- 체크아웃해 코드를 꺼낼 때보다 체크인해서 코드를 넣을 때 더 깨끗한 상태로 만들어야 함

## 클린 아키텍처

- 업무 정책/로직은 상세조건을 몰라야 함
- 상세조건 : ui, 인터페이스, 외부조건, 디비, …
- 강한 결합을 끊기위해 interface를 사용해야 함

## SRP(단일 책임 원칙)

- 메소드는 하나의 일만 잘 해야 함 (이것저것 하면 안됨)

## DRY(Don’t Repeat Yourself) 원칙

- 반복 금지
- 동일하거나 유사한 코드가 반복되는 경우 메소드로 추출할 수 있는지 확인

## 명명규칙

- 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다.
- Info, Data는 a, an, the와 마찬가지로 의미가 불분명한 불용어다.
- 발음하기 쉬운 이름을 선택한다.
- 검색하기 좋은 이름이 상수보다 좋다.
- 루프에서 반복 횟수를 세는 변수 i,j,k는 괜찮다 ( 업계 표준)

## 클래스

- 구현을 감추려면 추상화가 필요
- 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 함
- 객체는 동작을 공개하고 자료를 숨김

## 메소드(함수)

- 작게 만들어라.
- 들여쓰기 수준은 1단이나 2단을 넘어서는 안 된다.
- 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.
- 이상적인 인수 개수는 0(무항)개다. 다음은 1(단항)개, 다음은 2(이항)개다.
- 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 안 된다.

## 주석

- 주석은 언제나 실패를 의미한다.
- 진실은 한곳에만 존재한다. 바로 코드다.
- 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.
- open api를 만든다면 훌륭한 주석을 작성하라.

## 파일 포맷팅

- prettier사용 (vscode, intellij 에 모두 존재)  
  Prettier · Opinionated Code Formatter
- 가능하면 기본값 사용
- 수정시 다른 팀원에게도 알려주기(다른 팀원들도 동일하게 설정해야 하기 때문에)
- 적절한 행 길이 유지
- 개념은 빈 행으로 분리

## 파일 인코딩

- UTF-8

## 들여쓰기(indent)

- space 2개 사용
- tab 문자 사용하지 않음

## null 리턴 지양

- 가능하면 null을 리턴하지 않음
- 자바의 경우 Optional()사용 권장

## Optional()

- null처리를 위해 사용
- 가능하면 직접 null처리를 하지 않음

## 문자열사용, enum

- 가능하면 magic literal 사용하지 않음
- 불가피할 때 상수로 사용(static final String)
- enum 추천

## 메소드(함수) 길이

- 20줄을 넘지 않아야 함
- 20줄이 넘는 경우 메소드로 분리할 수 있는지 확인 필요

## tdd

- 테스트 코드 작성
- 실제 코드가 진화하면 테스트 코드도 진화해야 함
- 테스트 코드는 실제 코드 못지 않게 중요함
- 코드의 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 테스트 코드임
- 테스트 코드가 방치되어 망가지면 실제 코드도 망가짐

## 복잡한 로직

- 구현 로직이 복잡한 경우 설계가 잘 되었는지 확인하기
- 대부분 설계가 틀렸을 경우 구현이 복잡해짐

## JSON 포맷의 key 문자열 명명

- 낙타법(camelCase) 사용
- java, javascript진영에서는 낙타법을 많이 사용한다고 함

## URI 명명

- 소문자, 숫자, 하이픈만 사용 사용
- 언더바대신 하이픈(-)을 사용.
- 동사 사용 불허
- URI의 마지막에는 슬래시(/)를 포함하지 않음

## try…catch…

- try…catch…문은 비용이 많이 드는 코드로 사용을 추천하지 않음
  (예외가 발생하는 곳은 예외가 발생하는 이유가 있는 것임)
- 꼭 필요한 곳에만 사용
- 정말 try…catch…가 필요한 곳인지 고민 필요
- catch시 오류 메시지 로깅 또는 throw 필요

## 기타

- Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않음

## 로깅

- 환경(로컬/개발/테스트/운영)별 구분된 로깅 전략 필요
- 환경별 구분된 로깅 설정 필요
- 운영 환경 로깅에는 INFO, WARN, ERROR 사용(DEBUG 자제)
- 로그 파일은 보통 일별로 생성함. 1개 파일의 최대 크기 설정함. 호스트별로 로그파일 생성함
- 파일 명명: 어플리케이션명*yyyyMMdd*호스트명.log
- 로그 내용: 로그레벨 yyyy-MM-dd HH:mm:ss 로깅을실행한클래스명 로깅을실행한메소드명 줄번호 자유로운로그내용...
- 플랫폼, 언어등에 관계없이 적용
- 넷마블 로깅 팁
  - ERROR와 WARN 로그에는 꼭 stack trace와 context 정보를 넣는 것이 좋다.
  - INFO 레벨 로그에는 작업의 중간 진행상황을 기록하기 보다, 하나의 작업 단위가 완료되면 해당 작업을 요약한 내용을 기록하는 것이 좋다.
  - 편리하게 그룹화할 수 있도록 고유한 에러 코드를 필드에 추가하는 것이 좋다.
  - ...
- 로깅 레벨
  - ERROR : 개발팀이 의도하지 않은 오류로 인해 요청과 응답이 정상적으로 이루어지지 않은 경우
  - WARN : 당장 오류 상황이 아니거나 처리 가능한 오류상황이지만, 향후 시스템 에러로 이어질 수 있는 경우
  - INFO : 일반적인 사용자 요청과 응답의 요약, 또는 개발자가 의도한 오류 상황이 발생한 경우
  - DEBUG, TRACE : 개발용 로컬 환경에서 사

## 디렉터리 구조

- 서버의 디렉터리 구조 설정
  - 계정의 홈 디렉터리
  - 어플리케이션이 배포되는 디렉터리
  - 로그 파일이 생성되는 디렉터리
  - 업로드된 파일이 저장되는 디렉터리
  - ...

## 표준 매뉴얼 목차

- 표준 매뉴얼 목차 정의 필요
- 어플리케이션, 서비스마다 서로 다른 매뉴얼을 만들지 않아야 함
- 표준 목차가 있고, 어플리케이션/서비스별로 내용만 달라져야 함
- 사용자 메뉴얼 vs 관리자 매뉴얼 vs 시스템 운영자 매뉴얼
  - 사용자: 어플리케이션/서비스를 사용하는 일반 사용자
  - 관리자: 어플리케이션/서비스의 정보를 관리하는 사용자
  - 시스템 운영자: TA, AA로 생각할 수 있음. 어플리케이션/서비스가 잘 운영되도록 프로그램/시스템단을 관리하는 사용자

## 문서 명명

- 형식: 문서명*일자*버전.확장자
  - 문서명 : 고유의 문서명. 가능하면 변경불가
  - 일자 : 마지막으로 수정한 일자
  - 버전 : v0.1부터 시작. 수정할때마다 버전 업
  - 확장자 : 파일의 확장자
- 버전은 고유함
- 높은 버전의 문서가 가장 최근 문서임
